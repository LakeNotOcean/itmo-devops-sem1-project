name: Go Test Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

# Прежде всего тестируем локально, если тесты прошли - разворачиваем на удаленном сервере
jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: project-sem-1
          POSTGRES_USER: validator
          POSTGRES_PASSWORD: val1dat0r
        ports:
          - 5432:5432
        volumes:
          - postgres_data:/var/lib/postgresql/data
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.25'

    - name: Make scripts executable
      run: |
        chmod +x scripts/tests.sh

    - name: Create .env for tests
      run: |
        mkdir -p ./configs
        cat > ./configs/.env << EOF
        # Backend
        PORT=8080
        IDLE_TIMEOUT=${{ secrets.IDLE_TIMEOUT }}
        MAX_FILE_SIZE=${{ secrets.MAX_FILE_SIZE }}
        TEMP_FILE_DIR=${{ secrets.TEMP_FILE_DIR }}
        DATA_FILE_NAME=${{ secrets.DATA_FILE_NAME }}
        BATCH_SIZE=${{ secrets.BATCH_SIZE }}
        # Database
        POSTGRES_HOST=localhost
        POSTGRES_PORT=5432
        POSTGRES_DB=project-sem-1
        POSTGRES_USER=validator
        POSTGRES_PASSWORD=val1dat0r
        EOF

    - name: Run Go application for tests
      run: |
        go build -o app ./cmd/app/sem1-final-project-hard-level
        ./app &
        APP_PID=$!
        echo "Application started with PID: $APP_PID"
        sleep 10
    - name: Test Level 1
      id: test-level-1
      continue-on-error: true
      run: ./scripts/tests.sh 1
      env:
        POSTGRES_HOST: localhost
        POSTGRES_PORT: 5432
        POSTGRES_DB: project-sem-1
        POSTGRES_USER: validator
        POSTGRES_PASSWORD: val1dat0r

    - name: Test Level 2
      id: test-level-2
      continue-on-error: true
      run: ./scripts/tests.sh 2
      env:
        POSTGRES_HOST: localhost
        POSTGRES_PORT: 5432
        POSTGRES_DB: project-sem-1
        POSTGRES_USER: validator
        POSTGRES_PASSWORD: val1dat0r

    - name: Test Level 3
      id: test-level-3
      continue-on-error: true
      run: ./scripts/tests.sh 3
      env:
        POSTGRES_HOST: localhost
        POSTGRES_PORT: 5432
        POSTGRES_DB: project-sem-1
        POSTGRES_USER: validator
        POSTGRES_PASSWORD: val1dat0r

    - name: Check test results
      if: always()
      run: |
        if [[ "${{ steps.test-level-1.outcome }}" == "success" ]] || \
           [[ "${{ steps.test-level-2.outcome }}" == "success" ]] || \
           [[ "${{ steps.test-level-3.outcome }}" == "success" ]]; then
          echo "At least one test level passed successfully!"
          exit 0
        else
          echo "All test levels failed!"
          exit 1
        fi
  # Деплой осуществляется командой ./run.sh, не уверен, что имеет смысл делать отдельные actions с повторением логики
  # Инфраструктура и зависимости не переустанавливаются при их наличии
  deploy:
    name: Deploy to Remote Server
    runs-on: ubuntu-latest
    needs: test
    if: success() 

    steps:
    - uses: actions/checkout@v4

    - name: Install Deploy Dependecies
      run: |
        curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
        sudo apt install -y jq
        echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH

    - name: Configure Yandex Cloud CLI
      env:
        YC_TOKEN: ${{ secrets.YC_TOKEN }}
        YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
        YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
      run: |
        yc config set token $YC_TOKEN
        
        if [ -n "$YC_CLOUD_ID" ]; then
          yc config set cloud-id $YC_CLOUD_ID
        fi
        
        if [ -n "$YC_FOLDER_ID" ]; then
          yc config set folder-id $YC_FOLDER_ID
        fi
        
    - name: Create full .env for deploy
      run: |
        mkdir -p ./configs
        cat > ./configs/.env << EOF
        # Backend
        PORT=${{ secrets.PORT }}
        IDLE_TIMEOUT=${{ secrets.IDLE_TIMEOUT }}
        MAX_FILE_SIZE=${{ secrets.MAX_FILE_SIZE }}
        TEMP_FILE_DIR=${{ secrets.TEMP_FILE_DIR }}
        DATA_FILE_NAME=${{ secrets.DATA_FILE_NAME }}
        BATCH_SIZE=${{ secrets.BATCH_SIZE }}
        
        # Database
        POSTGRES_DB=${{ secrets.POSTGRES_DB }}
        POSTGRES_USER=${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        DB_HOST=${{ secrets.DB_HOST }}
        DB_PORT=${{ secrets.DB_PORT }}
        
        # Docker
        DOCKER_IMAGE_NAME=${{ secrets.DOCKER_IMAGE_NAME }}
        
        # Deploy
        VM_IP=${{ secrets.VM_IP }}
        SSH_USER=${{ secrets.SSH_USER }}
        SSH_KEY_PRIVATE="${{ secrets.SSH_KEY_PRIVATE }}"
        REMOTE_DIR=${{ secrets.REMOTE_DIR }}
        YC_FOLDER_ID=${{ secrets.YC_FOLDER_ID }}
        VM_NAME=${{ secrets.VM_NAME }}
        NETWORK_NAME=${{ secrets.NETWORK_NAME }}
        SUBNET_NAME=${{ secrets.SUBNET_NAME }}
        YC_ZONE=${{ secrets.YC_ZONE }}
        SUBNET_CIDR=${{ secrets.SUBNET_CIDR }}
        USE_PREEMPTIBLE=${{ secrets.USE_PREEMPTIBLE }}
        PLATFORM_ID=${{ secrets.PLATFORM_ID }}
        VM_CORES=${{ secrets.VM_CORES }}
        VM_MEMORY=${{ secrets.VM_MEMORY }}
        CORE_FRACTION=${{ secrets.CORE_FRACTION }}
        VM_DISK_SIZE=${{ secrets.VM_DISK_SIZE }}
        VM_IMAGE=${{ secrets.VM_IMAGE }}
        SSH_KEY_PUB="${{ secrets.SSH_KEY_PUB }}"
        EOF

    - name: Create SSH keys directory and files
      env:
        PRIVATE_KEY_CONTENT: ${{ secrets.SSH_PRIVATE_KEY_CONTENT }}
        PUBLIC_KEY_CONTENT: ${{ secrets.SSH_PUBLIC_KEY_CONTENT }}
        PRIVATE_KEY_PATH: ${{ secrets.SSH_KEY_PRIVATE }}
        PUBLIC_KEY_PATH: ${{ secrets.SSH_KEY_PUB }}
      run: |
        mkdir -p $(dirname "$PRIVATE_KEY_PATH")
        echo "$PRIVATE_KEY_CONTENT" > "$PRIVATE_KEY_PATH"
        echo "$PUBLIC_KEY_CONTENT" > "$PUBLIC_KEY_PATH"
        chmod 600 "$PRIVATE_KEY_PATH"

    - name: Make scripts executable
      run: |
        chmod +x scripts/helpers/create-infrastructure.sh
        chmod +x scripts/helpers/deploy-application.sh
        chmod +x scripts/helpers/install-dependencies.sh
        chmod +x scripts/prepare.sh
        chmod +x scripts/run.sh
        chmod +x scripts/tests.sh

    - name: Run deploy script
      run: ./scripts/run.sh

  # уведомление в чат-боте Телеграма
  telegram-notify:
    runs-on: ubuntu-latest
    if: always()
    needs: 
      - test 
      - deploy
    steps:
      - name: Send Telegram message on commit
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          message: |
            ${{ format('Workflow {0}', github.workflow) }} completed!
            Repository: ${{ github.repository }}
            Commit: ${{ github.sha }}
            Message: ${{ github.event.head_commit.message }}
            
            Jobs status:
            - Tests: ${{ needs.tests.result }}
            - Push Docker: ${{ needs.push-docker-images.result }}
            - Deploy: ${{ needs.deploy.result }}
            - Auto Tests: ${{ needs.auto-tests.result }}


